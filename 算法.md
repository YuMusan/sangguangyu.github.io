# 数学
### Bit Manipulation 位操作
##### Get Bit
此方法将相关位 移到第零个位置。然后，对一个具有类似0001的位模式的位执行 AND与操作。这会清楚原始数字中除相关位以外的所有位。如果相关位为1，则结果为1，否则结果为0.
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */
export default function getBit(number, bitPosition) {
  return (number >> bitPosition) & 1;
}
```
##### Set Bit
此方法将 bitPosition位移1，创建一个看起来像00100的值，然后执行or或运算，将特定位设置为1，但不影响该数字的其他位。
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */
export default function setBit(number, bitPosition) {
  return number | (1 << bitPosition);
}
```
##### Cleat Bit
此方法将1 移位bitPosition位，创建一个看起来像00100的值，然后，它将此掩码反转以得到看起来像11011的数字。然后将AND与操作应用于该数字和掩码。该操作会取消位
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */
export default function clearBit(number, bitPosition) {
  const mask = ~(1 << bitPosition);

  return number & mask;
}
```
##### Update Bit
此方法是"清除位"和"设置位"方法的组合。
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @param {number} bitValue - 0 or 1.
 * @return {number}
 */
export default function updataBit(number, bitPosition, bitValue) {
    // normalized bit value
    const bitValueNormalized = bitValue?1:0;
    //init clear mask
    const clearMask = ~(1 << bitPosition);
    //clear bit value and then set it up to required value
    return (number & clearMask) | (bitValueNormalized << bitPosition)
}
```
##### isEven
此方法确定提供的数字是否为偶数。这是基于奇数的最后一个正确位被设置为1的事实。
```text
Number: 5 = 0b0101
isEven: false

Number: 4 = 0b0100
isEven: true
```
```js
/**
 * @param {number} number
 * @return {boolean}
 */
export default function isEven(number) {
    retrun (number & 1) === 0;
}
```
##### isPositive
此方法确定数字是否为正。它基于这样一个事实：所有正数的最左边的位都设置为0。但是，如果提供的数字为零或负零，则仍应返回false。
```text
Number: 1 = 0b0001
isPositive: true

Number: -1 = -0b0001
isPositive: false
```
```js
/**
 * @param {number} number - 32-bit integer.
 * @return {boolean}
 */
export default function isPositive(number) {
    //Zero is neither a positive nor a negative number
    if(number === 0) {
        return false
    }
    //the most significant 32nd bit can be used to determine whether the number is positive.
    return ((number >> 31) & 1) === 0; 
}
```
##### Multiply By Two 乘以2
此方法将原始数字向左移动一位。因此，所有二进制数的分量（2的幂）都是乘2的，因此数字本身是乘2的。
```text
Before the shift
Number: 0b0101 = 5
Powers of two: 0 + 2^2 + 0 + 2^0

After the shift
Number: 0b1010 = 10
Powers of two: 2^3 + 0 + 2^1 + 0
```
```js
/**
 * @param {number} number
 * @return {number}
 */
export default function multiplyByTwo(number) {
    return number << 1;
}
```
##### Divide By Two
此方法将原始数字向右移动一位。因此，所有二进制数的分量（2的幂）都被2除，因此数字本身被2除，没有余数。
```text
Before the shift
Number: 0b0101 = 5
Powers of two: 0 + 2^2 + 0 + 2^0

After the shift
Number: 0b0010 = 2
Powers of two: 0 + 0 + 2^1 + 0
```
```js
/**
 * @param {number} number
 * @return {number}
 */
export default function divdeByTwo(number) {
    return number >> 1;
}
```
##### Switch Sign
这种方法使正数变成负数和倒数。为了做到这一点，它使用了“两个补码”的方法，通过反转数字的所有位并加上1来实现。
```text
1101 -3
1110 -2
1111 -1
0000  0
0001  1
0010  2
0011  3
```
```js
/**
 * Switch the sign of the number using "Twos Complement" approach.
 * @param {number} number
 * @return {number}
 */
export default function switchSign(number) {
    return ~number + 1;
}
```
##### Multiply Two Signed Numbers 两个有符号的数字相乘
此方法使用位运算符将两个有符号整数相乘。该方法基于以下事实：
```text
a * b can be written in the below formats:
  0                     if a is zero or b is zero or both a and b are zeroes
  2a * (b/2)            if b is even
  2a * (b - 1)/2 + a    if b is odd and positive
  2a * (b + 1)/2 - a    if b is odd and negative
```
这种方法的优点是，在每个递归步骤中，一个操作数减少到其原始值的一半。因此，运行时复杂性为O（log（b）），其中b是在每个递归步骤上减少到一半的操作数。
```js
function isEven(number) {
    retrun (number & 1) === 0;
}

function isPositive(number) {
    //Zero is neither a positive nor a negative number
    if(number === 0) {
        return false
    }
    //the most significant 32nd bit can be used to determine whether the number is positive.
    return ((number >> 31) & 1) === 0; 
}

function multiplyByTwo(number) {
    return number << 1;
}

function divdeByTwo(number) {
    return number >> 1;
}

export default function multiply(a,b) {
    // if a is zero or b is zero or if both a and b are zeros then the pro duction is also zero
    if (b === 0 || a === 0) {
        return 0;
    }
    // Otherwise we will have four different cases that are described above.
    const multiplyByOddPositive = ()=> multiply(multiplyByTwo(a),divideByTwo(b-1)) + a;
    const multiplyByOddNegative = ()=> multiply(multiplyByTwo(a),divideByTwo(b+1)) - a;
    const multiplyByEven = ()=> multiply(multiplyByTwo(a),devideByTwo(b));
    const multiplyByOdd = ()=> (isPositive(b) ? multiplyByOddPositive() : multiplyByOddNegative());
    return isEven(b) ? multiplyByEven() : multiplyByOdd();
}
```
##### Multiply Two Unsigned Numbers 两个无符号数相乘
此方法使用按位运算将两个整数相乘。该方法基于--每个数字都可以表示为2的幂的和
逐位相乘的主要思想是，每个数可以被分解成两个幂的和:`19 = 2^4 + 2^1 + 2^0`
然后将x乘以19等于：`x * 19 = x * 2^4 + x * 2^1 + x * 2^0`
现在需要记住，x * 2 ^ 4等效于将x左移4位（x << 4）。
```js
/**
 * Multiply to unsigned numbers using bitwise operator.
 *
 * The main idea of bitwise multiplication is that every number may be split
 * to the sum of powers of two:
 *
 * I.e. 19 = 2^4 + 2^1 + 2^0
 *
 * Then multiplying number x by 19 is equivalent of:
 *
 * x * 19 = x * 2^4 + x * 2^1 + x * 2^0
 *
 * Now we need to remember that (x * 2^4) is equivalent of shifting x left by 4 bits (x << 4).
 *
 * @param {number} number1
 * @param {number} number2
 * @return {number}
 */
 export default function multiplyUnsigned(number1, number2) {
 	let result = 0;
 	//let's treat number2 as a multiplier for the number1
 	let multiplier = number2;
 	// Multiplier current bit index
 	let bitIndex = 0;
 	//Go through all bits of number2
 	while (multiplier !== 0) {
 		//check if current multiplier bit is set
 		if (multiplier & 1) {
 			// in case if multiplier's bit at position bitIndex is set
 			// it would mean that we need to multiply number1 by the power
 			// of bit with index bitIndex and then add if to the result
 			result += (number1 << bitIndex);
 		}
 		bitIndex += 1;
 		multiplier >>= 1;
 	}
 	return result;
 }
```
##### Count Set Bits
此方法使用按位运算符对数字中设置的位数进行计数。 主要思想是我们一次将数字右移一位，并检查＆运算的结果（如果设置了位）为1，否则为0。
```text
Number: 5 = 0b0101
Count of set bits = 2
```
```js
/**
 * @param {number} originalNumber
 * @return {number}
 */
 export default function countSetBits(originalNumber) {
 	let setBitsCount = 0;
 	let number = originalNumber;
 	while(number) {
 		setBitsCount += number & 1;
 		//shift number right by one bit to investigate other bits.
 		number >>= 1;
 	}
 	return itsCount;
 }
```
##### Count Bits to Flip One Number to Another
此方法输出将一个数字转换为另一个数字所需的位数。这利用了以下特性：当数字进行异或运算(XOR-ed)时，结果将是不同位数的数量。
```text
5 = 0b0101
1 = 0b0001
Count of Bits to be Flipped: 1
```
```js
function countSetBits(originalNumber) {
 	let setBitsCount = 0;
 	let number = originalNumber;
 	while(number) {
 		setBitsCount += number & 1;
 		//shift number right by one bit to investigate other bits.
 		number >>= 1;
 	}
 	retrun setBitsCount;
 }
 export default function bitsDiff(numberA,numberB) {
 	return countSetBits(numberA ^ numberB)
 }
```
##### Count Bits of a Number
要计算有价值的位数，需要每次向左移一位，以查看移位数是否大于输入数。
```text
5 = 0b0101
Count of valuable bits is: 3
When we shift 1 four times it will become bigger than 5.
```
```js
/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
 export default function bitLength(number) {
 	let bitsCounter = 0;
 	while((1<< bitsCounter) <= number) {
 		bitsCounter += 1;
 	}
 	return bitsCounter;
 }
```
##### Is Power of Two
此方法检查提供的数字是否为2的幂。 它使用以下属性。 假设powerNumber是一个以2的幂构成的数字（即2、4、8、16等）。 然后，如果我们要在powerNumber和powerNumber之间进行＆操作-1，它将返回0（如果number是2的幂）。
```text
Number: 4 = 0b0100
Number: 3 = (4 - 1) = 0b0011
4 & 3 = 0b0100 & 0b0011 = 0b0000 <-- Equal to zero, is power of two.

Number: 10 = 0b01010
Number: 9 = (10 - 1) = 0b01001
10 & 9 = 0b01010 & 0b01001 = 0b01000 <-- Not equal to zero, not a power of two.
```
```js
/**
 * @param {number} number
 * @return bool
 */
 export default function isPowerOfTwo(number) {
 	return (number & (number -1)) === 0;
 }
```
##### Full Adder
此方法使用按位运算符将两个整数相加。
它实现了全加法器电子电路逻辑，以二进制补码形式将两个32位整数相加。 它使用布尔逻辑来涵盖添加两个输入位的所有可能情况：添加前一个较不重要的阶段后，带或不带“进位”。
Legend:
* A: Number A
* B: Number B
* ai: ith bit of number A
* bi: ith bit of number B
* carryIn: a bit carried in from the previous less-significant stage
* carryOut: a bit to carry to the next most-significant stage
* bitSum: The sum of ai, bi, and carryIn
* resultBin: The full result of adding current stage with all less-significant stages (in binary)
* resultDec: The full result of adding current stage with all less-significant stages (in decimal)
```
```text
A = 3: 011
B = 6: 110
┌──────┬────┬────┬─────────┬──────────┬─────────┬───────────┬───────────┐
│  bit │ ai │ bi │ carryIn │ carryOut │  bitSum │ resultBin │ resultDec │
├──────┼────┼────┼─────────┼──────────┼─────────┼───────────┼───────────┤
│   0  │ 1  │ 0  │    0    │    0     │     1   │       1   │     1     │
│   1  │ 1  │ 1  │    0    │    1     │     0   │      01   │     1     │
│   2  │ 0  │ 1  │    1    │    1     │     0   │     001   │     1     │
│   3  │ 0  │ 0  │    1    │    0     │     1   │    1001   │     9     │
└──────┴────┴────┴─────────┴──────────┴─────────┴───────────┴───────────┘
```
```js
/**
 * Add two numbers using only binary operators.
 *
 * This is an implementation of full adders logic circuit.
 *
 * Table(1)
 *  INPUT  | OUT
 *  C Ai Bi | C Si | Row
 * -------- | -----| ---
 *  0  0  0 | 0  0 | 1
 *  0  0  1 | 0  1 | 2
 *  0  1  0 | 0  1 | 3
 *  0  1  1 | 1  0 | 4
 * -------- | ---- | --
 *  1  0  0 | 0  1 | 5
 *  1  0  1 | 1  0 | 6
 *  1  1  0 | 1  0 | 7
 *  1  1  1 | 1  1 | 8
 * ---------------------
 *
 * Legend:
 * INPUT C = Carry in, from the previous less-significant stage
 * INPUT Ai = ith bit of Number A
 * INPUT Bi = ith bit of Number B
 * OUT C = Carry out to the next most-significant stage
 * OUT Si = Bit Sum, ith least significant bit of the result
 *
 *
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
 function getBit(number, bitPosition) {
 	return (number >> bitPosition) & 1;
}
export default function fullAdder(a,b) {
	let result = 0;
	let carry = 0;
	// the operands of all bitwise operators are converted to signed
	// 32-bit integers in two's complement format
	for (let i = 0; i < 32; i += 1) {
		const ai = getBit(a, i);
		const bi = getBit(b, i);
		const carry = carry;
		//calculate binary ai+bi without carry(half adder)
		// See Table(1) rows 1 - 4: Si = Ai ^ Bi
		const aiPlusBi = ai ^ bi ;
		//calculate ith bit of the result by adding the carry bit to ai+bi
		// For Table(1) rows 5 - 8 carryIn = 1: Si = Ai ^ Bi ^ 1, flip the bit
    		// Fpr Table(1) rows 1 - 4 carryIn = 0: Si = Ai ^ Bi ^ 0, a no-op.
    		const bitSum = aiPlusBi ^ carryIn;
    		//carry out one to the next most-significant stage
    		//when at least one of these is true:
    		// 1) Table(1) rows 6, 7: one of Ai OR Bi is 1 AND carryIn = 1
    		// 2) Table(1) rows 4, 8: Both Ai AND Bi are 1
    		const carryOut = (aiPlusbi & carryIn) | (ai & bi);
    		carry = carryOut;
    		//set ith least significant bit of the result to bitSum
    		result |= bitSum << i;
		}
		return result;
}
```
### Factoril 阶乘
在数学中，用n！表示的非负整数n的阶乘是所有小于或等于n的正整数的乘积。
`5! = 5 * 4 * 3 * 2 * 1 = 120`
```js
/*
* @param {number} num
*/
//尾递归的优化
function factoril_1(i,a) {
	a = a||1;
	if(i<2) {
		return a;
	}
	return factoril_1(i-1,a*i);
}
//闭包
function factoril_2(num) {
	if(num<=1) {
		return 1;
	}else{
		return num*factoril_2(num-1);
	}
}
//for循环
function factoril_3(num) {
	for(let i=num-1;i>=1;i--) {
		num *= i;
	}
	return num;
}
//while循环
function factoril_4(num) {
	let result = num;
	while(num>1) {
		num--;
		result *= num;
	}
	return result;
}
```
##### Fibonacci Number
在数学中，斐波那契数列是以下整数序列中的数字，其特征在于前两个数字之后的每个数字都是前两个数字的和：`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`
边长为连续斐波纳契数的正方形平铺

![alt](https://camo.githubusercontent.com/f653fca3a6fcf1733d0b19c3ddb37622926b42e7/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f642f64622f333425324132312d4669626f6e61636369426c6f636b732e706e67)

斐波那契螺旋：通过绘制连接斐波那契平铺中正方形的相对角的圆弧而创建的金色螺旋的近似值； [4]该三角形使用大小为1、1、2、3、5、8、13和21的正方形.

![alt](https://camo.githubusercontent.com/e1127247ec2da22f21e548352a86e7180f10d7bf/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f322f32652f4669626f6e6163636953706972616c2e737667)

```js
/**
 * Return a fibonacci sequence as an array.
 *以数组形式返回斐波那契数列
 * @param n
 * @return {number[]}
 */
 function fibonacci(n) {
 	const fibSequence = [1];
 	let currentValue = 1;
 	let previousValue = 0;
 	if(n===0) {
 		return fibSequence
 	}
 	let iterationCounter = n-1;
 	while(iterationCounter) {
 		currentValue += previousValue;
 		previousValue = currentValue -previousValue;
 		fibSequence.push(currentValue);
 		iterationCounter--;
 	}
 	return fibSequence;
 }
```
```js
/**
 * Calculate fibonacci number at specific position using Dynamic Programming approach.
 *使用动态编程方法计算特定位置的斐波那契数。
 * @param n
 * @return {number}
 */
 function fibonacciNth(n) {
 	let currentValue = 1;
 	let previousValue = 0;

	if (n === 1) {
		return 1;
	}
  	let iterationsCounter = n - 1;
  	while (iterationsCounter) {
  		currentValue += previousValue;
  		previousValue = currentValue - previousValue;
  		iterationsCounter--;;
  	}
  	return currentValue;
}
function fibo()	{
    let [pre,curr] = [0,1];
    for(;;)	{
        yield curr;
        [pre,curr] = [curr,pre + curr];
    }
}
for(let i of fibo())
{
    if(i > 10000)
    {
        break;
    }
    console.log(i);
}
```
```js
/**
 * Calculate fibonacci number at specific position using closed form function (Binet's formula).
 * 使用封闭形式函数（Binet公式）计算特定位置的斐波那契数。
 * @param {number} position - Position number of fibonacci sequence (must be number from 1 to 75).
 * @return {number}
 */

```
