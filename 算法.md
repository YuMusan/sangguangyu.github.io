# 数学
### Bit Manipulation 位操作
##### Get Bit
此方法将相关位 移到第零个位置。然后，对一个具有类似0001的位模式的位执行 AND与操作。这会清楚原始数字中除相关位以外的所有位。如果相关位为1，则结果为1，否则结果为0.
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */
export default function getBit(number, bitPosition) {
  return (number >> bitPosition) & 1;
}
```
##### Set Bit
此方法将 bitPosition位移1，创建一个看起来像00100的值，然后执行or或运算，将特定位设置为1，但不影响该数字的其他位。
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */
export default function setBit(number, bitPosition) {
  return number | (1 << bitPosition);
}
```
##### Cleat Bit
此方法将1 移位bitPosition位，创建一个看起来像00100的值，然后，它将此掩码反转以得到看起来像11011的数字。然后将AND与操作应用于该数字和掩码。该操作会取消位
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */
export default function clearBit(number, bitPosition) {
  const mask = ~(1 << bitPosition);

  return number & mask;
}
```
##### Update Bit
此方法是"清除位"和"设置位"方法的组合。
```js
/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @param {number} bitValue - 0 or 1.
 * @return {number}
 */
export default function updataBit(number, bitPosition, bitValue) {
    // normalized bit value
    const bitValueNormalized = bitValue?1:0;
    //init clear mask
    const clearMask = ~(1 << bitPosition);
    //clear bit value and then set it up to required value
    return (number & clearMask) | (bitValueNormalized << bitPosition)
}
```
##### isEven
此方法确定提供的数字是否为偶数。这是基于奇数的最后一个正确位被设置为1的事实。
```text
Number: 5 = 0b0101
isEven: false

Number: 4 = 0b0100
isEven: true
```
```js
/**
 * @param {number} number
 * @return {boolean}
 */
export default function isEven(number) {
    return (number & 1) === 0;
}
```
##### isPositive
此方法确定数字是否为正。它基于这样一个事实：所有正数的最左边的位都设置为0。但是，如果提供的数字为零或负零，则仍应返回false。
```text
Number: 1 = 0b0001
isPositive: true

Number: -1 = -0b0001
isPositive: false
```
```js
/**
 * @param {number} number - 32-bit integer.
 * @return {boolean}
 */
export default function isPositive(number) {
    //Zero is neither a positive nor a negative number
    if(number === 0) {
        return false
    }
    //the most significant 32nd bit can be used to determine whether the number is positive.
    return ((number >> 31) & 1) === 0; 
}
```
##### Multiply By Two 乘以2
此方法将原始数字向左移动一位。因此，所有二进制数的分量（2的幂）都是乘2的，因此数字本身是乘2的。
```text
Before the shift
Number: 0b0101 = 5
Powers of two: 0 + 2^2 + 0 + 2^0

After the shift
Number: 0b1010 = 10
Powers of two: 2^3 + 0 + 2^1 + 0
```
```js
/**
 * @param {number} number
 * @return {number}
 */
export default function multiplyByTwo(number) {
    return number << 1;
}
```
##### Divide By Two
此方法将原始数字向右移动一位。因此，所有二进制数的分量（2的幂）都被2除，因此数字本身被2除，没有余数。
```text
Before the shift
Number: 0b0101 = 5
Powers of two: 0 + 2^2 + 0 + 2^0

After the shift
Number: 0b0010 = 2
Powers of two: 0 + 0 + 2^1 + 0
```
```js
/**
 * @param {number} number
 * @return {number}
 */
export default function divdeByTwo(number) {
    return number >> 1;
}
```
##### Switch Sign
这种方法使正数变成负数和倒数。为了做到这一点，它使用了“两个补码”的方法，通过反转数字的所有位并加上1来实现。
```text
1101 -3
1110 -2
1111 -1
0000  0
0001  1
0010  2
0011  3
```
```js
/**
 * Switch the sign of the number using "Twos Complement" approach.
 * @param {number} number
 * @return {number}
 */
export default function switchSign(number) {
    return ~number + 1;
}
```
##### Multiply Two Signed Numbers 两个有符号的数字相乘
此方法使用位运算符将两个有符号整数相乘。该方法基于以下事实：
```text
a * b can be written in the below formats:
  0                     if a is zero or b is zero or both a and b are zeroes
  2a * (b/2)            if b is even
  2a * (b - 1)/2 + a    if b is odd and positive
  2a * (b + 1)/2 - a    if b is odd and negative
```
这种方法的优点是，在每个递归步骤中，一个操作数减少到其原始值的一半。因此，运行时复杂性为O（log（b）），其中b是在每个递归步骤上减少到一半的操作数。
```js
function isEven(number) {
    return (number & 1) === 0;
}

function isPositive(number) {
    //Zero is neither a positive nor a negative number
    if(number === 0) {
        return false
    }
    //the most significant 32nd bit can be used to determine whether the number is positive.
    return ((number >> 31) & 1) === 0; 
}

function multiplyByTwo(number) {
    return number << 1;
}

function divdeByTwo(number) {
    return number >> 1;
}

export default function multiply(a,b) {
    // if a is zero or b is zero or if both a and b are zeros then the pro duction is also zero
    if (b === 0 || a === 0) {
        return 0;
    }
    // Otherwise we will have four different cases that are described above.
    const multiplyByOddPositive = ()=> multiply(multiplyByTwo(a),divideByTwo(b-1)) + a;
    const multiplyByOddNegative = ()=> multiply(multiplyByTwo(a),divideByTwo(b+1)) - a;
    const multiplyByEven = ()=> multiply(multiplyByTwo(a),devideByTwo(b));
    const multiplyByOdd = ()=> (isPositive(b) ? multiplyByOddPositive() : multiplyByOddNegative());
    return isEven(b) ? multiplyByEven() : multiplyByOdd();
}
```
##### Multiply Two Unsigned Numbers 两个无符号数相乘
此方法使用按位运算将两个整数相乘。该方法基于--每个数字都可以表示为2的幂的和
逐位相乘的主要思想是，每个数可以被分解成两个幂的和:`19 = 2^4 + 2^1 + 2^0`
然后将x乘以19等于：`x * 19 = x * 2^4 + x * 2^1 + x * 2^0`
现在需要记住，x * 2 ^ 4等效于将x左移4位（x << 4）。
```js
/**
 * Multiply to unsigned numbers using bitwise operator.
 *
 * The main idea of bitwise multiplication is that every number may be split
 * to the sum of powers of two:
 *
 * I.e. 19 = 2^4 + 2^1 + 2^0
 *
 * Then multiplying number x by 19 is equivalent of:
 *
 * x * 19 = x * 2^4 + x * 2^1 + x * 2^0
 *
 * Now we need to remember that (x * 2^4) is equivalent of shifting x left by 4 bits (x << 4).
 *
 * @param {number} number1
 * @param {number} number2
 * @return {number}
 */
 export default function multiplyUnsigned(number1, number2) {
 	let result = 0;
 	//let's treat number2 as a multiplier for the number1
 	let multiplier = number2;
 	// Multiplier current bit index
 	let bitIndex = 0;
 	//Go through all bits of number2
 	while (multiplier !== 0) {
 		//check if current multiplier bit is set
 		if (multiplier & 1) {
 			// in case if multiplier's bit at position bitIndex is set
 			// it would mean that we need to multiply number1 by the power
 			// of bit with index bitIndex and then add if to the result
 			result += (number1 << bitIndex);
 		}
 		bitIndex += 1;
 		multiplier >>= 1;
 	}
 	return result;
 }
```
##### Count Set Bits
此方法使用按位运算符对数字中设置的位数进行计数。 主要思想是我们一次将数字右移一位，并检查＆运算的结果（如果设置了位）为1，否则为0。
```text
Number: 5 = 0b0101
Count of set bits = 2
```
```js
/**
 * @param {number} originalNumber
 * @return {number}
 */
 export default function countSetBits(originalNumber) {
 	let setBitsCount = 0;
 	let number = originalNumber;
 	while(number) {
 		setBitsCount += number & 1;
 		//shift number right by one bit to investigate other bits.
 		number >>= 1;
 	}
 	return itsCount;
 }
```
##### Count Bits to Flip One Number to Another
此方法输出将一个数字转换为另一个数字所需的位数。这利用了以下特性：当数字进行异或运算(XOR-ed)时，结果将是不同位数的数量。
```text
5 = 0b0101
1 = 0b0001
Count of Bits to be Flipped: 1
```
```js
function countSetBits(originalNumber) {
 	let setBitsCount = 0;
 	let number = originalNumber;
 	while(number) {
 		setBitsCount += number & 1;
 		//shift number right by one bit to investigate other bits.
 		number >>= 1;
 	}
 	return setBitsCount;
 }
 export default function bitsDiff(numberA,numberB) {
 	return countSetBits(numberA ^ numberB)
 }
```
##### Count Bits of a Number
要计算有价值的位数，需要每次向左移一位，以查看移位数是否大于输入数。
```text
5 = 0b0101
Count of valuable bits is: 3
When we shift 1 four times it will become bigger than 5.
```
```js
/**
 * return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
 export default function bitLength(number) {
 	let bitsCounter = 0;
 	while((1<< bitsCounter) <= number) {
 		bitsCounter += 1;
 	}
 	return bitsCounter;
 }
```
##### Is Power of Two
此方法检查提供的数字是否为2的幂。 它使用以下属性。 假设powerNumber是一个以2的幂构成的数字（即2、4、8、16等）。 然后，如果我们要在powerNumber和powerNumber之间进行＆操作-1，它将返回0（如果number是2的幂）。
```text
Number: 4 = 0b0100
Number: 3 = (4 - 1) = 0b0011
4 & 3 = 0b0100 & 0b0011 = 0b0000 <-- Equal to zero, is power of two.

Number: 10 = 0b01010
Number: 9 = (10 - 1) = 0b01001
10 & 9 = 0b01010 & 0b01001 = 0b01000 <-- Not equal to zero, not a power of two.
```
```js
/**
 * @param {number} number
 * @return bool
 */
 export default function isPowerOfTwo(number) {
 	return (number & (number -1)) === 0;
 }
```
##### Full Adder
此方法使用按位运算符将两个整数相加。
它实现了全加法器电子电路逻辑，以二进制补码形式将两个32位整数相加。 它使用布尔逻辑来涵盖添加两个输入位的所有可能情况：添加前一个较不重要的阶段后，带或不带“进位”。
Legend:
* A: Number A
* B: Number B
* ai: ith bit of number A
* bi: ith bit of number B
* carryIn: a bit carried in from the previous less-significant stage
* carryOut: a bit to carry to the next most-significant stage
* bitSum: The sum of ai, bi, and carryIn
* resultBin: The full result of adding current stage with all less-significant stages (in binary)
* resultDec: The full result of adding current stage with all less-significant stages (in decimal)
```
```text
A = 3: 011
B = 6: 110
┌──────┬────┬────┬─────────┬──────────┬─────────┬───────────┬───────────┐
│  bit │ ai │ bi │ carryIn │ carryOut │  bitSum │ resultBin │ resultDec │
├──────┼────┼────┼─────────┼──────────┼─────────┼───────────┼───────────┤
│   0  │ 1  │ 0  │    0    │    0     │     1   │       1   │     1     │
│   1  │ 1  │ 1  │    0    │    1     │     0   │      01   │     1     │
│   2  │ 0  │ 1  │    1    │    1     │     0   │     001   │     1     │
│   3  │ 0  │ 0  │    1    │    0     │     1   │    1001   │     9     │
└──────┴────┴────┴─────────┴──────────┴─────────┴───────────┴───────────┘
```
```js
/**
 * Add two numbers using only binary operators.
 *
 * This is an implementation of full adders logic circuit.
 *
 * Table(1)
 *  INPUT  | OUT
 *  C Ai Bi | C Si | Row
 * -------- | -----| ---
 *  0  0  0 | 0  0 | 1
 *  0  0  1 | 0  1 | 2
 *  0  1  0 | 0  1 | 3
 *  0  1  1 | 1  0 | 4
 * -------- | ---- | --
 *  1  0  0 | 0  1 | 5
 *  1  0  1 | 1  0 | 6
 *  1  1  0 | 1  0 | 7
 *  1  1  1 | 1  1 | 8
 * ---------------------
 *
 * Legend:
 * INPUT C = Carry in, from the previous less-significant stage
 * INPUT Ai = ith bit of Number A
 * INPUT Bi = ith bit of Number B
 * OUT C = Carry out to the next most-significant stage
 * OUT Si = Bit Sum, ith least significant bit of the result
 *
 *
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
 function getBit(number, bitPosition) {
 	return (number >> bitPosition) & 1;
}
export default function fullAdder(a,b) {
	let result = 0;
	let carry = 0;
	// the operands of all bitwise operators are converted to signed
	// 32-bit integers in two's complement format
	for (let i = 0; i < 32; i += 1) {
		const ai = getBit(a, i);
		const bi = getBit(b, i);
		const carry = carry;
		//calculate binary ai+bi without carry(half adder)
		// See Table(1) rows 1 - 4: Si = Ai ^ Bi
		const aiPlusBi = ai ^ bi ;
		//calculate ith bit of the result by adding the carry bit to ai+bi
		// For Table(1) rows 5 - 8 carryIn = 1: Si = Ai ^ Bi ^ 1, flip the bit
    	// Fpr Table(1) rows 1 - 4 carryIn = 0: Si = Ai ^ Bi ^ 0, a no-op.
    	const bitSum = aiPlusBi ^ carryIn;
    	//carry out one to the next most-significant stage
    	//when at least one of these is true:
    	// 1) Table(1) rows 6, 7: one of Ai OR Bi is 1 AND carryIn = 1
    	// 2) Table(1) rows 4, 8: Both Ai AND Bi are 1
    	const carryOut = (aiPlusbi & carryIn) | (ai & bi);
    	carry = carryOut;
    	//set ith least significant bit of the result to bitSum
    	result |= bitSum << i;
	}
	return result;
}
```

### Factoril 阶乘
在数学中，用n！表示的非负整数n的阶乘是所有小于或等于n的正整数的乘积。
`5! = 5 * 4 * 3 * 2 * 1 = 120`
```js
/*
* @param {number} num
*/
//尾递归的优化
function factoril_1(i,a) {
	a = a||1;
	if(i<2) {
		return a;
	}
	return factoril_1(i-1,a*i);
}
//闭包
function factoril_2(num) {
	if(num<=1) {
		return 1;
	}else{
		return num*factoril_2(num-1);
	}
}
//for循环
function factoril_3(num) {
	for(let i=num-1;i>=1;i--) {
		num *= i;
	}
	return num;
}
//while循环
function factoril_4(num) {
	let result = num;
	while(num>1) {
		num--;
		result *= num;
	}
	return result;
}
```
##### Fibonacci Number
在数学中，斐波那契数列是以下整数序列中的数字，其特征在于前两个数字之后的每个数字都是前两个数字的和：`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`
边长为连续斐波纳契数的正方形平铺

![alt](https://camo.githubusercontent.com/f653fca3a6fcf1733d0b19c3ddb37622926b42e7/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f642f64622f333425324132312d4669626f6e61636369426c6f636b732e706e67)

斐波那契螺旋：通过绘制连接斐波那契平铺中正方形的相对角的圆弧而创建的金色螺旋的近似值； [4]该三角形使用大小为1、1、2、3、5、8、13和21的正方形.

![alt](https://camo.githubusercontent.com/e1127247ec2da22f21e548352a86e7180f10d7bf/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f322f32652f4669626f6e6163636953706972616c2e737667)

```js
/**
 * Return a fibonacci sequence as an array.
 *以数组形式返回斐波那契数列
 * @param n
 * @return {number[]}
 */
 function fibonacci(n) {
 	const fibSequence = [1];
 	let currentValue = 1;
 	let previousValue = 0;
 	if(n===0) {
 		return fibSequence
 	}
 	let iterationCounter = n-1;
 	while(iterationCounter) {
 		currentValue += previousValue;
 		previousValue = currentValue -previousValue;
 		fibSequence.push(currentValue);
 		iterationCounter--;
 	}
 	return fibSequence;
 }
```
```js
/**
 * Calculate fibonacci number at specific position using Dynamic Programming approach.
 *使用动态编程方法计算特定位置的斐波那契数。
 * @param n
 * @return {number}
 */
 function fibonacciNth(n) {
 	let currentValue = 1;
 	let previousValue = 0;

	if (n === 1) {
		return 1;
	}
  	let iterationsCounter = n - 1;
  	while (iterationsCounter) {
  		currentValue += previousValue;
  		previousValue = currentValue - previousValue;
  		iterationsCounter--;;
  	}
  	return currentValue;
}
function fibo()	{
    let [pre,curr] = [0,1];
    for(;;)	{
        yield curr;
        [pre,curr] = [curr,pre + curr];
    }
}
for(let i of fibo())
{
    if(i > 10000)
    {
        break;
    }
    console.log(i);
}
```
```js
/**
 * Calculate fibonacci number at specific position using closed form function (Binet's formula).
 * 使用封闭形式函数（Binet公式）计算特定位置的斐波那契数。
 *
 * @param {number} position - Position number of fibonacci sequence (must be number from 1 to 75).
 * @return {number}
 */
 function fibonacciClosedForm(position) {
 	cosnt topMaxValidPosition = 70;
 	//check that position is valid
 	if(position<1 || position>topMaxValidPosition) {
 		throw new Error(`Can't handle position smaller than 1 or greater than ${topMaxValidPosition}`)
 	}
 	//calculate √5 to re-use it in futher formulas
 	const sqrt5 = Math.sqrt(5);
 	//calculate φ constant (≈1.61803)
 	const phi = (1+sqrt5)/2;
 	//calculate fibonacci number using binet's formula
 	return Math.floor((phi ** position)/sqrt5+0.5)
 } 
```
##### Primality Test
质数（或素数）是大于1的自然数，不能通过将两个较小的自然数相乘而形成。 大于1的非质数自然数称为复合数。 例如，5是质数，因为将其写为乘积的唯一方式是1×5或5×1，涉及5本身。 但是，6是复合的，因为它是两个都小于6的两个数字（2×3）的乘积。

![alt](https://camo.githubusercontent.com/8da56db2bd124541a05194f940b61c974e69968b/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f662f66302f5072696d65732d76732d636f6d706f73697465732e737667)

素数测试是一种用于确定输入数字是否为素数的算法。 在数学的其他领域中，它用于加密。 与整数分解不同，素数测试通常不给出素数，而仅说明输入数是否为素数。 分解被认为是一个计算难题，而素数测试相对容易（其运行时间是输入大小的多项式）。
```js
/**
 * @param {number} number\
 *排除法
 * @return {boolean}
 */
 export default function trialDivision(number) {
 	//check if number is integer
 	if(number%1!==0) {
 		return false;
 	}
 	if(number<=1) {
 		//if number is less than one then it isn't prime by definition
 		return false;
 	}
 	if(number<=3) {
 		//all number from 2 to 3 are prime
 		return true;
 	}
 	if(number%2===0) {
 		return false;
 	}
 	//if there is no dividers up to square root of n then there is no higher dividers as well
 	const dividerLimit = Math.sqrt(number);
 	for(let divider = 3; divider<=dividerLimit; divider += 2) {
 		if(number % divider ===0 ) {
 			return false;
 		}
 	}
 	return true;
 }

```
##### Euclidean algorithm 欧几里得算法-计算最大公约数
在数学中，欧几里得算法是计算两个数字的最大公约数（GCD）的有效方法，该最大公约数可将两个数除而无余数。
欧几里得算法基于这样的原理：如果将较大的数字替换为较小的数字，则两个数字的最大公约数不变。 例如，21是252和105的GCD（因为252 = 21×12和105 = 21×5），相同的数字21也是105和252-105 = 147的GCD。 对这两个数字中的一个进行重复，重复此过程，将得出连续较小的数字对，直到两个数字相等为止。 发生这种情况时，它们就是原始两个数字的GCD。
通过反转步骤，可以将GCD表示为两个原始数字的总和，每个数字乘以一个正整数或负整数，例如21 = 5×105 +（-2）×252。 以这种方式表达的被称为贝祖定理。

![alt](https://camo.githubusercontent.com/62ad940498abce3d7ef639978bb694d4bfae149c/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f332f33372f4575636c6964253237735f616c676f726974686d5f426f6f6b5f5649495f50726f706f736974696f6e5f325f332e706e67)

欧几里得的方法用于找到两个起始长度BA和DC的最大公约数（GCD），两者均定义为共同“单位”长度的倍数。长度DC较短，用于'测量'BA，但仅一次，因为剩余的EA小于DC。 EA现在测量（两倍）较短的长度DC，其余FC比EA短。然后，FC测量（三倍）长度EA。 因为没有余数，所以该过程以FC为GCD结束。 在右边的尼科马修斯的例子中，数字49和21导致GCD为7（源自希思1908：300）。
一个24 x 60的矩形覆盖有十个12x12的正方形拼贴，其中12是GCD为24和60。更一般而言，a x b矩形可以覆盖边长为c的正方形拼贴 仅当c是a和b的公约数时。
基于减法的欧几里得算法动画。 初始矩形的尺寸为a = 1071和b =462。大小为462×462的正方形放置在其中，剩下462×147矩形。 将该矩形用147×147正方形平铺，直到剩下21×147矩形，然后再用21×21正方形平铺，不留任何未覆盖区域。 最小的正方形大小为21，即GCD为1071和462。

![alt](https://camo.githubusercontent.com/eaf4fa99b80cbb864f56a4f180231887b684f360/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f312f31632f4575636c696465616e5f616c676f726974686d5f313037315f3436322e676966)

```js
/**
 * Recursive version of Euclidean Algorithm of finding greatest common divisor (GCD).
 *查找最大公约数（GCD）的欧几里德算法的递归版本。
 * @param {number} originalA
 * @param {number} originalB
 * @return {number}
 */
 export default function euclideanAlgorithm(originalA,originalB) {
 	//make input numbers positive
 	const a = Math.abs(originalA);
 	const b = Math.abs(originalB);
 	//to make algorithm work faster instead of subtracting one number from the other
 	//we may use modulo operation
 	return (b===0) ? a:euclideanAlgorithm(b, a%b)
 }
```
```js
/**
 * Iterative version of Euclidean Algorithm of finding greatest common divisor (GCD).
 *查找最大公约数（GCD）的欧几里德算法的迭代版本。
 * @param {number} originalA
 * @param {number} originalB
 * @return {number}
 */
 export default function euclideanAlgorithmItreative(originalA,originalB) {
 	// subtract one number from another until both numbers would become the seam.
 	// this will be out GCD ,also quit the loop if one of the numbers is zero.
 	while(a&&b&&a!==b) {
 		[a, b]= a>b ? [a-b,b] : [a, b-a];
 	}
 	//return the number that is not equal to zero since the last subtraction(it will be a GCD)
 	return a || b;
 }
```
