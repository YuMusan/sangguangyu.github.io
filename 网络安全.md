# XML注入
### 什么是XML
XML指可扩展标记语言`eXtensible Markup Language`，被设计用来传输和存储数据。

一个XML文档可能是这个样子：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note>
```
文档中是一个便签，这个便签具有自我描述性，它包含了发送者和接收者的信息，同时拥有标题以及消息主体。它没有做任何事情，需要编写软件或者程序，才能传输、接收或者显示这个文档

> * XML的设计宗旨是传输数据，不是显示数据
> * XML标签没有被预定义，需要自行定义标签，被设计为具有自我描述性

### xml与HTML的差异
* HTML 被设计用来显示数据，其焦点是数据的外观
* XML 被设计用来结构化、传输和存储数据，其焦点是数据的内容

通过XML，数据能够存储在独立的XML文件中，这样可以专注使用HTML、CSS进行显示和布局，修改底层数据时不再需要对HTML进行任何改变。通过使用几行JavaScript代码，就可以读取一个外部XML文件，更新网页的数据内容。

### XML树结构
XML 文档是一种树结构，它从根部开始，然后扩展到枝叶

```xml
<?xml version="1.0" encoding="UTF-8"?>
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>
    <main lang="en">Don't forget me this weekend!</main>
    <ps>If you forget, it won't end well. :)</ps>
  </body>
</note>
```
第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）。

下一行描述文档的根元素（像在说："本文档是一个便签"）
接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）

最后一行定义根元素的结尾

父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。

所有的元素都可以有文本内容和属性（类似 HTML 中）。

### XML 语法规则
* XML文档必须有根元素
* XML声明,声明文件的可选部分，如果存在需要放在文档的第一行
* 所有的 XML 元素都必须有一个关闭标签
* XML 标签对大小写敏感
* XML 必须正确嵌套
* XML 属性值必须加引号
* 在 XML 中，空格会被保留
* 实体引用，在 XML 中，一些字符拥有特殊的意义。为了避免错误，请用实体引用来代替

XML 元素 vs 属性
```xml
<person sex="female">
<firstname>Anna</firstname>
<lastname>Smith</lastname>
</person>
```
```xml
<person>
<sex>female</sex>
<firstname>Anna</firstname>
<lastname>Smith</lastname>
</person>
```

在第一个实例中，sex 是一个属性。在第二个实例中，sex 是一个元素。这两个实例都提供相同的信息。

没有什么规矩告诉什么时候该使用属性，而什么时候该使用元素。在 HTML 中，属性用起来很便利，但是在 XML 中，应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素。

### 验证 XML 文档
合法的 XML 文档是"形式良好"的 XML 文档，这也符合文档类型定义（DTD）的规则：
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE note SYSTEM "Note.dtd">
<note>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Don't forget me this weekend!</body>
</note>
```
```text
<!DOCTYPE note
[
<!ELEMENT note (to,from,heading,body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)>
]>
```
文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。

DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。
假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：

`<!DOCTYPE root-element [element-declarations]>`

内部实体声明:
```xml
<?xml version="1.0"?>
<!DOCTYPE test [
<!ENTITY writer "r1ght0us">
<!ENTITY BLOG "http://r1ght0us.xyz">
]>

<test>&writer;&copyright;</test>
```
假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：

`<!DOCTYPE root-element SYSTEM "filename">`

外部实体声明:
```xml
<?xml version="1.0"?>
<!DOCTYPE test [
<!ENTITY writer SYSTEM "https://github.com/r1ght0us">
<!ENTITY handsome SYSTEM "http://www.chenguanxin.com">
]>
<author>&writer;&handsome;</author>
```
加载一个 XML 文件
```xml
<html>
<body>
<h1>W3Schools Internal Note</h1>
<div>
<b>To:</b> <span id="to"></span><br />
<b>From:</b> <span id="from"></span><br />
<b>Message:</b> <span id="message"></span>
</div>

<script>
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xmlhttp=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
}
xmlhttp.open("GET","note.xml",false);
xmlhttp.send();
xmlDoc=xmlhttp.responseXML;

document.getElementById("to").innerHTML=
xmlDoc.getElementsByTagName("to")[0].childNodes[0].nodeValue;
document.getElementById("from").innerHTML=
xmlDoc.getElementsByTagName("from")[0].childNodes[0].nodeValue;
document.getElementById("message").innerHTML=
xmlDoc.getElementsByTagName("body")[0].childNodes[0].nodeValue;
</script>

</body>
</html>
```

XML 命名空间 
XML 命名空间提供避免元素命名冲突的方法。在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。

在 XML 中的命名冲突可以通过使用名称前缀从而容易地避免。
```xml
<h:table>
<h:tr>
<h:td>Apples</h:td>
<h:td>Bananas</h:td>
</h:tr>
</h:table>

<f:table>
<f:name>African Coffee Table</f:name>
<f:width>80</f:width>
<f:length>120</f:length>
</f:table>
```

XML 命名空间 - xmlns 属性

当在 XML 中使用前缀时，一个所谓的用于前缀的命名空间必须被定义。命名空间是在元素的开始标签的 xmlns 属性中定义的。

命名空间声明的语法如下。xmlns:前缀="URI"。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。

```xml
<root xmlns:h="http://www.w3.org/TR/html4/"
xmlns:f="http://www.w3cschool.cc/furniture">

<h:table>
<h:tr>
<h:td>Apples</h:td>
<h:td>Bananas</h:td>
</h:tr>
</h:table>

<f:table>
<f:name>African Coffee Table</f:name>
<f:width>80</f:width>
<f:length>120</f:length>
</f:table>

</root>
```

解析xml文件

## SQL注入
SQL注入攻击是通过操作输入来修改SQL语句，用以达到执行代码对WEB服务器进行攻击的方法。post/get web表单、输入域名或页面请求的查询字符串中插入SQL命令，最终使web服务器执行恶意命令的过程。

涉及的方面：

动态查询

## url跳转漏洞
### OAuth 认证
[OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html),对OAuth认证的详细解释。

授权码模式：

授权劫持
根据OAuth的认证流程,用户授权凭证会由服务器转发到redirect_uri对应的地址,如果攻击者伪造redirect_uri为自己的地址,然后诱导用户发送该请求,之后获取的凭证就会发送给攻击者伪造的回调地址.攻击者使用该凭证即可登录用户账号,造成授权劫持.

## CSRF

CSRF全拼为Cross Site Request Forgery，译为跨站请求伪造。
CSRF指攻击者盗用了你的身份，以你的名义发送恶意请求。
包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......
造成的问题：个人隐私泄露以及财产安全。

### CSRF的大致流程

![CSRF](https://img-blog.csdnimg.cn/20190116112233873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjA2OTcz,size_16,color_FFFFFF,t_70)

防止 CSRF 攻击

步骤

1. 在客户端向后端请求界面数据的时候，后端会往响应中的 cookie 中设置 csrf_token 的值
2. 在 Form 表单中添加一个隐藏的的字段，值也是 csrf_token
3. 在用户点击提交的时候，会带上这两个值向后台发起请求
4. 后端接受到请求，以会以下几件事件：
        * 从 cookie中取出 csrf_token
        * 从 表单数据中取出来隐藏的 csrf_token 的值
        * 进行对比
5. 如果比较之后两值一样，那么代表是正常的请求，如果没取到或者比较不一样，代表不是正常的请求，不执行下一步操作

登录的时候设置crsf_Token

![crsfToken](./csrfToken.png)

## SSRF
服务器端请求伪造（也称为SSRF）是一个网络安全漏洞，攻击者可以利用该漏洞诱使服务器端应用程序向攻击者选择的任意域发出HTTP请求。

在典型的SSRF示例中，攻击者可能引导服务器建立连接，使其自身，组织基础结构中的其他基于Web的服务或外部第三方系统建立连接。
